import argparse
from typing import Type, List, Union, Optional

import libcst as cst
from django.db.models import Model, ForeignKey, Field
from libcst.codemod import CodemodContext, VisitorBasedCodemodCommand
from libcst.codemod.visitors import AddImportsVisitor
from libcst.metadata import FullyQualifiedNameProvider

from django_type_gen.metadata_provider import DjangoMetadataProvider


def get_primary_key_field(model_cls: Type[Model]) -> Field:
    for field in model_cls._meta.get_fields():
        if isinstance(field, Field):
            if field.primary_key:
                return field
    raise ValueError("No primary key defined")


AUTO_GENERATED_CODE_START = "# region django-magic-types"
AUTO_GENERATED_CODE_END = "# endregion django-magic-types"


class AddModelAttrs(VisitorBasedCodemodCommand):
    DESCRIPTION: str = "Foo"

    METADATA_DEPENDENCIES = (DjangoMetadataProvider, FullyQualifiedNameProvider)

    def __init__(self, context: CodemodContext):
        super().__init__(context)
        self.indent_depth = 0
        self.in_class_name = []

    def visit_Module(self, node: cst.Module) -> Optional[bool]:
        self.models_in_module: List[Type[Model]] = self.get_metadata(DjangoMetadataProvider, node, [])
        return True

    def visit_IndentedBlock(self, node: cst.IndentedBlock) -> None:
        self.indent_depth += 1

    def visit_ClassDef(self, node: cst.ClassDef) -> None:
        self.in_class_name.append(node.name.value)

    def leave_ClassDef(
            self, original_node: cst.ClassDef, updated_node: cst.ClassDef
    ) -> Union[cst.BaseStatement, cst.FlattenSentinel[cst.BaseStatement], cst.RemovalSentinel]:
        self.in_class_name.pop()
        return updated_node

    def leave_IndentedBlock(
            self, original_node: cst.IndentedBlock, updated_node: cst.IndentedBlock
    ) -> cst.BaseSuite:
        self.indent_depth -= 1
        if self.indent_depth != 0:
            return original_node
        if len(self.in_class_name) != 1:
            return original_node
        class_name = self.in_class_name[0]
        if class_name not in [m.__name__ for m in self.models_in_module]:
            return original_node
        model_cls = next(m for m in self.models_in_module if m.__name__ == class_name)

        modified_body = []
        original_body = updated_node.body

        # Remove any existing auto-generated regions
        in_autogenerated_region = False
        for node in original_body:
            if isinstance(node, cst.EmptyLine):
                if node.comment == AUTO_GENERATED_CODE_START:
                    in_autogenerated_region = True
                    continue
                elif node.comment == AUTO_GENERATED_CODE_END:
                    in_autogenerated_region = False
                    continue
            if not in_autogenerated_region:
                modified_body.append(node)


        # TODO: If attr already exists, don't add it
        # TODO: Add proper imports if necessary
        # TODO: Use proper type
        AddImportsVisitor.add_needed_import(
            self.context, "typing", "Optional",
        )

        generated_body = [cst.EmptyLine(comment=cst.Comment(value=AUTO_GENERATED_CODE_START))]

        # Add auto-created primary key field
        pk_field = get_primary_key_field(model_cls)
        if pk_field.auto_created:
            # TODO: Map to type
            statement = cst.parse_statement(f"{pk_field.attname}: int")
            generated_body.append(statement)

        # Add "pk" field if not abstract
        if not model_cls._meta.abstract:
            # TODO: Use pk_field and map it to type
            statement = cst.parse_statement(f"pk: int")
            generated_body.append(statement)

        # Add "_id" fields for ForeignKeys
        for field in model_cls._meta.get_fields(include_parents=False):
            if isinstance(field, ForeignKey):
                # TODO: Get actual PK type of field.remote_field
                field_type = "int"
                full_field_type = field_type if not field.null else f"Optional[{field_type}]"
                statement = cst.parse_statement(f"{field.attname}: {full_field_type}")
                generated_body.append(statement)
        generated_body.append(cst.EmptyLine(comment=cst.Comment(value=AUTO_GENERATED_CODE_END)))
        return updated_node.with_changes(body=[*generated_body, *modified_body])
